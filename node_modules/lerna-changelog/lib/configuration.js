"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var execa = require("execa");
var normalize = require("normalize-git-url");
var configuration_error_1 = require("./configuration-error");
function load(options) {
    if (options === void 0) { options = {}; }
    var cwd = process.cwd();
    var rootPath = execa.sync("git", ["rev-parse", "--show-toplevel"], { cwd: cwd }).stdout;
    return fromPath(rootPath, options);
}
exports.load = load;
function fromPath(rootPath, options) {
    if (options === void 0) { options = {}; }
    var config = fromPackageConfig(rootPath) || fromLernaConfig(rootPath) || {};
    var repo = config.repo, nextVersion = config.nextVersion, labels = config.labels, cacheDir = config.cacheDir, ignoreCommitters = config.ignoreCommitters;
    if (!repo) {
        repo = findRepo(rootPath);
        if (!repo) {
            throw new configuration_error_1.default('Could not infer "repo" from the "package.json" file.');
        }
    }
    if (options.nextVersionFromMetadata || config.nextVersionFromMetadata) {
        nextVersion = findNextVersion(rootPath);
        if (!nextVersion) {
            throw new configuration_error_1.default('Could not infer "nextVersion" from the "package.json" file.');
        }
    }
    if (!labels) {
        labels = {
            breaking: ":boom: Breaking Change",
            enhancement: ":rocket: Enhancement",
            bug: ":bug: Bug Fix",
            documentation: ":memo: Documentation",
            internal: ":house: Internal",
        };
    }
    if (!ignoreCommitters) {
        ignoreCommitters = [
            "dependabot-bot",
            "dependabot[bot]",
            "greenkeeperio-bot",
            "greenkeeper[bot]",
            "renovate-bot",
            "renovate[bot]",
        ];
    }
    return {
        repo: repo,
        nextVersion: nextVersion,
        rootPath: rootPath,
        labels: labels,
        ignoreCommitters: ignoreCommitters,
        cacheDir: cacheDir,
    };
}
exports.fromPath = fromPath;
function fromLernaConfig(rootPath) {
    var lernaPath = path.join(rootPath, "lerna.json");
    if (fs.existsSync(lernaPath)) {
        return JSON.parse(fs.readFileSync(lernaPath)).changelog;
    }
}
function fromPackageConfig(rootPath) {
    var pkgPath = path.join(rootPath, "package.json");
    if (fs.existsSync(pkgPath)) {
        return JSON.parse(fs.readFileSync(pkgPath)).changelog;
    }
}
function findRepo(rootPath) {
    var pkgPath = path.join(rootPath, "package.json");
    if (!fs.existsSync(pkgPath)) {
        return;
    }
    var pkg = JSON.parse(fs.readFileSync(pkgPath));
    if (!pkg.repository) {
        return;
    }
    return findRepoFromPkg(pkg);
}
function findNextVersion(rootPath) {
    var pkgPath = path.join(rootPath, "package.json");
    var lernaPath = path.join(rootPath, "lerna.json");
    var pkg = fs.existsSync(pkgPath) ? JSON.parse(fs.readFileSync(pkgPath)) : {};
    var lerna = fs.existsSync(lernaPath) ? JSON.parse(fs.readFileSync(lernaPath)) : {};
    return pkg.version ? "v" + pkg.version : lerna.version ? "v" + lerna.version : undefined;
}
function findRepoFromPkg(pkg) {
    var url = pkg.repository.url || pkg.repository;
    var normalized = normalize(url).url;
    var match = normalized.match(/github\.com[:/]([^./]+\/[^./]+)(?:\.git)?/);
    if (!match) {
        return;
    }
    return match[1];
}
exports.findRepoFromPkg = findRepoFromPkg;
